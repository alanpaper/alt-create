{
  "doc_info_list": [
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<pre><code>项目立项和需求问题不做讨论。只是记录一下，前端项目从项目搭建到项目上线的过程。\n</code></pre>\n<h3>起始（项目搭建）</h3>\n<p>首先，框架选择上，公司统一用的react，也没有做什么技术评审，直接react hook拿来用了。</p>\n<ol>\n<li>\n<p>搭建使用的是create-react-app搭建的项目进行了reject。需要修改部分webpack配置。</p>\n</li>\n<li>\n<p>项目计划全部采用Hooks进行开发。用到的主要生态工具<code>rxjs</code>、``echarts<code>、</code>Typescript<code>、</code>SCSS<code>、</code>antd`等。</p>\n</li>\n<li>\n<p>考虑到项目以后可能会有多人协作开发, 使用了<code>husky</code>、<code>prettier</code>。等代码检查和整理工具，再代码提交时进行代码的格式化。</p>\n</li>\n<li>\n<p>全局接入<code>keycloak</code>。</p>\n</li>\n<li>\n<p>不引入redux. 原因：小范围的状态管理使用useContext代替，少量的全局状态，使用rxjs的subject进行简单封装即可。无大范围的状态管理，就没有考虑引入redux。</p>\n</li>\n</ol>\n<h3>开发（需求整理等）</h3>\n<p>项目一期分了多个大的模块，需要对接和同步更新不同的其他系统。整体规划是一个月进行一个模块的整理开发测试，和另外的系统相应功能的更新。</p>\n<p>开发中，首先就是ajax的封装，使用rxjs的ajax进行了封装。其次路由问题：由于采用keycloak，路由需要从远程获取配置信息，但是keycloak又不支持多余路由字段的配置，</p>\n<p>最后根据远程返回的菜单数据进行处理，根据字段匹配进行路由的动态渲染（前端需要维护一个路由文件）。</p>\n<h3>开发中遇到的问题</h3>\n<ol>\n<li>由于项目中有大量的表格和表单，一开始项目出现许多的重复代码。一开始想转换思路使用antd pro提供的组件，但是看到antd pro的代码，看不明白，感觉封装过度。\n最后就自己拿着antd的table自己做了简单封装，并自定义了公用的查询表单和table联动的useHooks，用起来还是蛮香的。去除了近一半的代码。(不喜勿喷)</li>\n</ol>\n<pre><code class=\"language-ts\">    import { useState, useMemo, useEffect, useCallback } from &quot;react&quot;;\n    import { Form } from &quot;antd&quot;;\n    import { defaultPagination, AntdPagination } from &quot;../config&quot;;\n    import { usePagination } from &quot;./usePagination&quot;;\n    import {\n      deleteObjectItemIfUndefined,\n      ITObject,\n    } from &quot;../utils/util&quot;;\n    import { ResponseData } from &quot;../utils/request&quot;;\n\n    export function useTableHooks&lt;T&gt;(observerCallback: Function) {\n      const [form] = Form.useForm();\n\n      const [defaultValue, setDefaultValue] = useState({});\n      const [loading, setLoading] = useState&lt;boolean&gt;(false);\n      const [list, setList] = useState&lt;T[]&gt;([]);\n      const { query, onChangePagination } = usePagination();\n      const [showPagination, setShowPagination] = useState&lt;AntdPagination&gt;(\n        defaultPagination\n      );\n\n      useEffect(() =&gt; {\n        setLoading(true);\n        const params = { ...defaultValue, ...query };\n        const subscriptions = observerCallback(params).subscribe(\n          (response: ResponseData) =&gt; {\n            if (response.code === &quot;200&quot;) {\n              const { list, total, pageNum } = response.data;\n              setList(list);\n              setShowPagination({ total, current: pageNum });\n            }\n            setLoading(false);\n          }\n        );\n        return () =&gt; {\n          subscriptions.unsubscribe();\n        };\n      }, [defaultValue, observerCallback, query]);\n\n      const onFinish = useCallback((values: ITObject) =&gt; {\n        setDefaultValue(deleteObjectItemIfUndefined(values));\n      }, []);\n\n      const handleReset = useCallback(() =&gt; {\n        form.resetFields();\n        setDefaultValue({});\n      }, [form]);\n\n      return useMemo(() =&gt; {\n        return {\n          form,\n          loading,\n          list,\n          defaultValue,\n          showPagination,\n          onChangePagination,\n          onFinish,\n          handleReset,\n          setDefaultValue,\n        };\n      }, [\n        defaultValue,\n        form,\n        handleReset,\n        list,\n        loading,\n        onChangePagination,\n        onFinish,\n        showPagination,\n      ]);\n    }\n</code></pre>\n<pre><code class=\"language-jsx\">    &lt;Form form={form} layout=&quot;inline&quot; onFinish={onFinish}&gt;\n      &lt;Form.Item&gt;\n        &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt;\n          查询\n        &lt;/Button&gt;\n      &lt;/Form.Item&gt;\n      &lt;Form.Item&gt;\n        &lt;Button onClick={handleReset}&gt;重置&lt;/Button&gt;\n      &lt;/Form.Item&gt;\n    &lt;/Form&gt;\n\n    &lt;StandardTable\n      loading={loading}\n      rowKey=&quot;code&quot;\n      dataSource={list}\n      columns={columns}\n      showPagination={showPagination}\n      onChange={onChangePagination}\n    /&gt;\n\n</code></pre>\n<p>还有就是hooks的使用每个页面进行了状态和布局的文件区分，把状态全部提取到useHooks中页面中只包含UI和布局信息.类似如下\n<code>index.jsx</code></p>\n<pre><code class=\"language-jsx\">    const TestManage: React.FC&lt;{}&gt; = () =&gt; {\n      const {\n        loading,\n        form,\n        columns,\n        onFinish,\n        list,\n        showPagination,\n        onChangePagination,\n        handleReset,\n      } = useTableHooks();\n\n      return (\n        &lt;MainContent&gt;\n          &lt;div&gt;&lt;/div&gt;\n        &lt;/MainContent&gt;\n      );\n    };\n</code></pre>\n<h3>项目的部署</h3>\n<p>项目全部使用jenkins进行自动化部署，前端只需要对仓库和sh命令脚本进行配置即可。具体的ngin运维人员进行配置。</p>\n<p>项目环境分为三个部分test环境、uat环境、和生产环境，每一次开发都会严格按照test-&gt; uat-&gt; 生产的流程发布。</p>\n<h3>存在问题</h3>\n<ol>\n<li>缺少单元测试。</li>\n<li>缺少文档。</li>\n</ol>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>微前端</h3>\n<pre><code>copy自后端提倡微服务，主要是为了解决，前端工程随着项目体积越来越大，带来的维护和开发上的问题。[微前端](https://micro-frontends.org/)\n</code></pre>\n<h4>微型前端背后的核心思想</h4>\n<ul>\n<li>\n<p>不受技术影响每个团队都应该能够选择和升级其堆栈，而无需与其他团队进行协调。自定义元素是隐藏实现细节同时为其他人提供中立界面的一种好方法。\n隔离团队代码</p>\n</li>\n<li>\n<p>即使所有团队都使用相同的框架，也不要共享运行时。构建独立的独立应用程序。不要依赖共享状态或全局变量。\n建立团队前缀</p>\n</li>\n<li>\n<p>同意尚无法隔离的命名约定。命名空间CSS，事件，本地存储和Cookies，以避免冲突并阐明所有权。\n优于自定义API的本机浏览器功能</p>\n</li>\n<li>\n<p>使用浏览器事件进行通信，而不是构建全局PubSub系统。如果确实需要构建跨团队API，请尝试使其尽可能简单。\n建立弹性站点</p>\n</li>\n<li>\n<p>即使JavaScript失败或尚未执行，您的功能也应该很有用。使用通用渲染和渐进增强来改善可感知的性能。</p>\n</li>\n</ul>\n<h4>主要想解决的问题</h4>\n<ol>\n<li>着时间的流逝，通常由独立团队开发的前端层会不断增长，并且变得越来越难以维护。包括打包速度，打包大小。(不适合少页面项目)</li>\n</ol>\n<h3>实现原则</h3>\n<p>使用不同框架本身编写的代码的客户端和服务器端集成之外，还应该讨论很多附带主题：隔离js的机制，避免css冲突，按需加载资源，在团队之间共享公共资源，处理数据获取并考虑为用户提供良好的加载状态。</p>\n<pre><code>总结：目前来说，微服务技术尚不成熟，可用工具很少，入坑的话，需要踩不少的坑，但是如果符合项目实际需要的话，对后期的维护来说，可谓真香。\n</code></pre>"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<pre><code>浏览器渲染页面前需要先构建DOM和CSSOM树。因此，我们需要确保尽快将HTML和CSS都提供给浏览器。\n</code></pre>\n<p>说明:</p>\n<ul>\n<li>字节 → 字符 → 令牌 → 节点 → 对象模型。</li>\n<li>HTML 标记转换成文档对象模型 (DOM)；CSS 标记转换成 CSS 对象模型 (CSSOM）。</li>\n<li>DOM 和 CSSOM 是独立的数据结构。</li>\n<li>Chrome DevTools Timeline 让我们可以捕获和检查 DOM 和 CSSOM 的构建和处理开销。</li>\n</ul>\n<h3>文档对象模型(DOM)</h3>\n<pre><code class=\"language-HTML\">    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n        &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n        &lt;title&gt;Critical Path&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n        &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n</code></pre>\n<p>让我们从最简单（可能）的情况入手：一个包含一些文本和一副图片的普通HTML页面。浏览器如何处理此页面？\n<img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" alt=\"渲染原理\" /></p>\n<ol>\n<li>转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</li>\n<li>令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“&lt;html&gt;”、“&lt;body&gt;”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li>\n<li>词法分析： 将令牌(标签)转换成定义其属性和规则的“对象”。</li>\n<li>DOM 构建： 最后，由于 HTML 标记定义了不同标记之间的关系（一些标记包含在其他标记内），使创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。</li>\n</ol>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/dom-tree.png\" alt=\"解析过程\" /></p>\n<p>整个流程的最终输出的是我们这个简单页面的文档对象模型 (DOM)，后面浏览器对页面进行的所有处理都会用到它。浏览器每次处理 HTML 标记时，都会完成以上所有步骤：将字节转换成字符，确定令牌，将令牌转换成节点，然后构建 DOM 树。这整个流程可能需要一些时间才能完成，有大量 HTML 需要处理时更是如此。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/dom-timeline.png\" alt=\"dom树渲染时间\" /></p>\n<p>如果您打开 Chrome DevTools 并在页面加载时记录时间线，就可以看到执行该步骤实际花费的时间。在上例中，将一堆 HTML 字节转换成 DOM 树大约需要 5 毫秒。对于较大的页面，这一过程需要的时间可能会显著增加。创建流畅动画时，如果浏览器需要处理大量 HTML，这很容易成为瓶颈。</p>\n<p>DOM 树捕获文档标记的属性和关系，但并未告诉我们元素在渲染后呈现的外观。那是 CSSOM 的责任。</p>\n<h3>CSS 对象模型 (CSSOM)</h3>\n<p>在浏览器构建我们这个简单页面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：</p>\n<pre><code class=\"language-CSS\">    body { font-size: 16px }\n    p { font-weight: bold }\n    span { color: red }\n    p span { display: none }\n    img { float: right }\n</code></pre>\n<p>我们本可以直接在 HTML 标记内声明样式（内联），但让 CSS 独立于 HTML 有利于我们将内容和设计作为独立关注点进行处理：设计人员负责处理 CSS，开发者侧重于 HTML，等等。</p>\n<p>与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png\" alt=\"css解析过程\" /></p>\n<p>CSS 字节转换成字符，接着转换成令牌和节点，最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" alt=\"渲染页面\" /></p>\n<p>CSSOM 为何具有树结构？为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算样式。</p>\n<p>以上面的 CSSOM 树为例进行更具体的阐述。span 标记内包含的任何置于 body 元素内的文本都将具有 16 像素字号，并且颜色为红色 — font-size 指令从 body 向下级联至 span。不过，如果某个 span 标记是某个段落 (p) 标记的子项，则其内容将不会显示。</p>\n<p>还请注意，以上树并非完整的 CSSOM 树，它只显示了我们决定在样式表中替换的样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即我们不提供任何自定义样式时所看到的样式，我们的样式只是替换这些默认样式（例如默认 IE 样式）。</p>\n<p>要了解 CSS 处理所需的时间，您可以在 DevTools 中记录时间线并寻找“Recalculate Style”事件：与 DOM 解析不同，该时间线不显示单独的“Parse CSS”条目，而是在这一个事件下一同捕获解析和 CSSOM 树构建，以及计算的样式的递归计算。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-timeline.png\" alt=\"css解析时间\" /></p>\n<p>我们的小样式表需要大约 0.6 毫秒的处理时间，影响页面上的 8 个元素 — 虽然不多，但同样会产生开销。不过，这 8 个元素从何而来呢？CSSOM 和 DOM 是独立的数据结构！结果证明，浏览器隐藏了一个重要步骤。接下来，让我们谈一谈将 DOM 与 CSSOM 关联在一起的渲染树。</p>\n<p>原文地址：\n<a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model\">原文地址</a></p>"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>Vim 常用快捷键</h3>\n<h4>进入vi的命令</h4>\n<pre><code>`vi filename` 打开或新建文件 并将光标置于第一行行首\n`vi + n filename` 打开文件 并将光标置于第n行行首\n`vi + /pattern filename` 打开文件，并将光标置于第一个与pattern匹配的串处\n`vi -r filename` 当vi编辑被意外关闭时，恢复filename\n</code></pre>\n<h4>移动光标命令</h4>\n<pre><code>`h` 光标左移一个字符\n`l` 光标右移一个字符\n`space` 光标右移一个字符\n`Backspace` 光标上移一行\n`k and Ctrl+p` 光标上移一行\n`j and Ctrl+n` 光标下移一行\n`Enter` 光标下移一行\n`w and W` 光标右移一个字符 位置：字符的句首\n`b and B` 光标左移一个字符 位置：字符的字尾\n`e and E` 光标右移一个字符 位置：字符的字尾\n`)` 光标移至句尾\n`(` 光标移至句首\n`}` 光标移至块的开头\n`{` 光标移至块的结尾\n`nG` 光标移至第n行 行首\n`n+` 光标下移n行\n`n-` 光标上移n行\n`n$` 光标移至第n行 行尾\n`H` 光标移至屏幕顶行 \n`M` 光标移至屏幕中间行\n`L` 光标移至屏幕最后一行\n`0` 数字0 光标移至当前行的行首\n`$` 光标移至当前行的 行尾\n</code></pre>\n<h4>屏幕翻滚命令</h4>\n<pre><code>`Ctrl+u` 向上翻半屏\n`Ctrl+d` 想下翻半屏\n`Ctrl+f` 想下翻一屏\n`Ctrl+b` 向上翻一屏\n`z + Enter` 将当前行翻滚至屏幕顶部 \n</code></pre>\n<h4>插入文本命令</h4>\n<pre><code>`i` 在光标前 插入文本\n`I` 在当前行 行首插入文本\n`a` 在光标后 插入文本\n`A` 在当前行 行尾插入文本\n`o` 在光标的下一行新开一行 \n`O` 在光标的上一行新开一行\n\n`r` 替换当前字符\n`R` 替换当前字符及其之后的字符`Esc`推出\n`s` 从当前光标位置处开始，以输入的文本替代指定数目的字符\n`S` 删除指定数目的行，并以输入的文本替\n</code></pre>\n<hr />\n<pre><code>`ncw and nCW` 修改指定数目的字   \n`nCC` 修改指定数目的行\n</code></pre>\n<hr />\n<h4>删除命令</h4>\n<pre><code>`ndw and ndW` 删除光标处开始及其后的n-1个字 \n`do` 删除至行首\n`d$` 删除至行尾 \n`ndd` 删除当前行及其后n-1行 \n`x || X` 删除一个字符，小写x删除光标后的字符,大写X删除光标前的字符\n`Ctrl+u` 删除输入方式下所输入的文本 \n</code></pre>\n<h4>搜索和替换命令</h4>\n<pre><code>`/pattern` 从光标开始向文件尾 搜索pattern\n`?pattern` 从光标开始向文件头 搜索pattern\n`n` 在同一个方向上重复上一次搜索命令\n`N` 在反方向上重复上一次搜索命令\n\n\n`:s/p1/p2/g` 将当前行中所有的p1替换成p2\n`:n1,n2s/p1/p2/g` 将第n1行至n2行中的所有p1替换成p2\n`:g/p1/s//p2/g` 将文件中的所有p1替换成p2\n</code></pre>\n<h4>操作行命令</h4>\n<pre><code>`: n1,n2 co n3` 将n1行到n2行之间的内容拷贝到第n3行下\n`: n1,n2 m n3` 将n1行到n2行之间的内容移动至第n3行下\n`: n1,n2 d` 将n1行到n2行之间的内容删除\n`: w` 保存当前文件\n`: e filename` 打开文件filename进行编辑\n`: x ` 保存当前文件并退出\n`: q` 推出vi\n`: q!` 不保存文件 并推出vi\n`：!command` 执行shell命令command \n`：n1,n2 w!command` 将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入 \n`：r!command` 将命令command的输出结果放到当前行 \n</code></pre>"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>1. 单例模式</h3>\n<p>一个应用程序中有且只有运行时的类，不能用new关键字实例化，</p>\n<p>实现：判断当前类是否已经被实例化，是则在运行时进行实例化，否的话直接使用之前已经存在的实例。存在多种实现，包括线程安全和线程不安全的几种实现</p>\n<h3>2. 工厂模式</h3>\n<p>首先抽象出来一个工厂类，然后根据需要每种产品再去继承抽象工厂，实现具体产品工厂类，最后使用各种实现的工厂类</p>\n<h3>3. 观察者模式</h3>\n<p>一个一对多的关系，首先观察者要到被观察者哪里进行注册，注册完成后，被观察者存在一份观察者列表，然后被观察者有什么风吹草动，会对列表进行遍历，通知每一个观察者。\n。观察者需要实现一个类方法，用来接收被观察者发来的数据。</p>\n<h3>4. 装饰者模式</h3>\n<p>举个例子：1块平板，敲文字不方便，就需要一个配个键盘，收入不方便，又要装一支手写笔，听歌又要搞个音响。</p>\n<p>简单来说就是一个基础类，为了实现所需功能，有在基础类的基础上继承来然后添加各自的功能。</p>\n<h3>5. 适配器模式</h3>\n<p>简单来说，有俩类，互不兼容，为了兼容，在两者中间搭一座桥梁，让功能可以使用，或者说数据可以通过。</p>"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>css 布局之flex布局</h3>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>安装</h3>\n<pre><code class=\"language-sh\">$ npm install husky lint-staged prettier pretty-quick --save-dev\n\n\n// 自动化生成.husky文件夹\n$ npm pkg set scripts.prepare=&quot;cd ../../ &amp;&amp; husky install /package/core/.husky&quot;\n\n// package.json添加\n&quot;scripts&quot;: {\n  &quot;pretty-quick&quot;: &quot;pretty-quick --staged&quot;,\n}\n&quot;husky&quot;: {\n  &quot;hooks&quot;: {\n    &quot;pre-commit&quot;: &quot;npm run pretty-quick&quot;\n  }\n},\n\n$ npm run prepare;\n\n$ npx husky add .husky/pre-commit &quot;npm run pretty-quick&quot;;\n\n// 打开当前目录下的.husky的pre-commit文件\n// 添加cd命令 操作目录从.git的文件根目录到当前目录的地址\n#!/usr/bin/env sh\n. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;\n\n\ncd package/core/\nnpm run pretty-quick\n\n\n\n// 完成后即可测试\n$ git add .husky/pre-commit\n\n</code></pre>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<blockquote>\n<p>python项目云服务器部署</p>\n</blockquote>\n<p>首先python项目打包就不说了，从把文件上传到服务器(centos7.4)开始：</p>\n<p>本地文件上传至服务器<code>scp</code> 第一个是本地文件地址，后一个是服务器ip和相应的文件保存地址。</p>\n<pre><code>scp /test/flaskr-1.0.0-py3-none-any.whl root@45.40.244.229:/upload/flaskr-1.0.0-py3-none-any.whl\n</code></pre>\n<p>文件上传好以后，云服务器安装python3，</p>\n<p>1.去官网找python3源码下载地址，使用wegt下载python3源码压缩包。</p>\n<p>先安装依赖环境，不然pip3安装的时候会报错。。。</p>\n<pre><code>  yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n\n\n  wegt https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz\n</code></pre>\n<p>解压：</p>\n<pre><code>  tar -zxvf Python-3.7.4.tgz\n</code></pre>\n<p>然后到/usr/local/目录下建立一个空目录python3.下面编译安装（gcc没有安装的话，可安装后继续，安装方法自行google）</p>\n<p>然后转到python3的解压文件夹目录下 <code>eg:/Python-3.7.4 </code> 执行以下</p>\n<pre><code>./configure --prefix=/usr/local/python3\n\nmake &amp;&amp; make install \n</code></pre>\n<p><code>make install</code> 这一步如果报错，需要google，大多数是依赖环境没有安装，安装一下就好。当然报错一定要先去把错误解决以后才能往下执行，不然后面会冒出来各种错\n比如安装好以后发现，虚拟环境打不开什么的。。</p>\n<p>执行完以后,添加软连接</p>\n<pre><code>ln -S /usr/local/python3/bin/python3 /usr/bin/python3\n</code></pre>\n<p>至此python3安装完成 还需要安装pip3工具</p>\n<pre><code>curl https://bootstrap.pypa.io/get-pip.py | python3\n</code></pre>\n<p>添加软连接</p>\n<pre><code>ln -S /usr/local/python3/bin/pip3 /usr/bin/pip3\n</code></pre>\n<p>python3安装完成以后，新建文件夹.env</p>\n<pre><code>  mkdir .env\n  python3 -m venv .env\n  . /.env/bin/activate\n\n\n  //切换目录\n  pip3 install flaskr-1.0.0-py3-none-any.whl\n  export FLASK_APP = flaskr\n  //初始化数据库\n  flask init_db\n\n  //安装生产环境服务器\n  pip install waitress\n\n  //启动服务\n  waitress-serve --call 'flaskr:create_app'\n\n</code></pre>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>渲染树构建、布局及绘制</h3>\n<p>CSSOM树和DOM树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，像像素渲染到屏幕上。\n优化上述每一个步骤对实现最佳渲染性能至关重要。</p>\n<p>在前面介绍构建对象模型的章节中，我们根据HTML和CSS输入构建了DOM树和CSSOM树。不过，它们都是独立的对象，\n分别网罗了文档不同方面的信息：一个描述内容，另一个则是描述需要对文档应用的样式规则。我们该如何将两者合并，让浏览器在屏幕上渲染像素哪？</p>\n<p>摘要：</p>\n<ul>\n<li>DOM树与CSSOM树合并后形成渲染树。</li>\n<li>渲染树只包含渲染网页所需的节点。</li>\n<li>布局计算每个对象的精确位置和大小。</li>\n<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。</li>\n</ul>\n<p>第一步是让浏览器将DOM和CSSOM合并成一个“渲染树”，网罗网页上所有可见的DOM内容，以及每个节点的所有CSSOM样式信息。\n<img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png\" alt=\"渲染树\" /></p>\n<p>为构建渲染树，浏览器大体上完成了下列工作：</p>\n<ol>\n<li>从DOM树的根节点开始遍历每个可见节点。</li>\n</ol>\n<ul>\n<li>某些节点不可见(如脚本标记、元标记等)，因为他们不会体现在渲染输出中，所以会被忽略。</li>\n<li>某些节点通过CSS隐藏，因此在渲染树中也会被忽略，列入，上例中的span节点--不会出现在渲染树种，--因为有一个显示规则在该节点上设置了“display: none”属性。</li>\n</ul>\n<ol start=\"2\">\n<li>对于每个可见节点，为期找到适配的CSSOM规则并应用它们。</li>\n<li>发射可见节点， 连同其内容和计算的样式。</li>\n</ol>\n<p>最终输出的渲染同时包含了屏幕上的所有可见内容及其样式信息。有了渲染树，我们就可以进入“布局”阶段。</p>\n<p>到目前为止，我们计算了哪些节点应该是可见的以及他们的计算样式，但我们尚未计算它们在设备视口内的确切为止和大小--这就是“布局”阶段，也成为“自动重排”。</p>\n<p>为弄清楚每个对象在网页的确切大小和位置，浏览器从渲染树的根节点开始进行遍历，让我们考虑下面的一个简单实例：</p>\n<pre><code class=\"language-HTML\">    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n        &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;div style=&quot;width: 50%&quot;&gt;\n          &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n</code></pre>\n<p>以上网页的正文包含两个嵌套div：第一个（父）div将节点的显示尺寸设置为视口宽度的50%，--父div包含的第二个div--将其宽度设置为其父项的50%；即视口宽度的25%。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/layout-viewport.png\" alt=\"布局\" /></p>\n<p>布局流程的输出是一个“盒模型”,他会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。</p>\n<p>最后，既然我们知道了哪些节点可见、它们的计算样式及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。</p>\n<p>上述步骤都需要浏览器完成大量工作，所以相当耗时。不过，chrome DevTools可以帮助我们对上述所有三个阶段进行深入的了解。让我们看一下最初“hello world”实例的布局阶段：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/layout-timeline.png\" alt=\"控制台\" /></p>\n<ul>\n<li>“Layout”事件在时间线中捕获渲染树结构以及位置和尺寸计算。</li>\n<li>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</li>\n</ul>\n<p>执行渲染树构建、布局和绘制所需的事件将取决于文档大小、应用的样式，以及运行文档的设备：文档越大，浏览器所需完成的工作就越多；样式越复杂，绘制所需的时间就越长(例如：单色的绘制开销“较小“，而阴影的计算和渲染开销则要”大的多“)。</p>\n<p>最后将在视口中看到下面的网页：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/device-dom-small.png\" alt=\"页面渲染图\" /></p>\n<p>下面简要概述了浏览器完成的步骤：</p>\n<ol>\n<li>处理HTML标记并构建DOM树。</li>\n<li>处理CSS标记并构建CSSOM树。</li>\n<li>将DOM与CSSOM合并成一个渲染树。</li>\n<li>根据渲染树来布局，以计算每个极端的几何信息。</li>\n<li>将各个节点绘制到屏幕上。</li>\n</ol>\n<p>我们的演示网页看起来可能很简单，实际上却需要完成相当多的工作。如果DOM或CSSOM被修改，您只能在执行一遍以上的步骤，以确定哪些像素需要在屏幕上进行重新渲染。</p>\n<p>优化关键渲染路径就是指最大限度缩短执行上述第一步至第五步耗费的总时间。这样一来，就能尽快将内弄渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。</p>\n<p>原文地址：</p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction\">原文地址</a></p>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>配置一个基于pnpm + react + rullup + typescript的组件开发库项目</h3>\n<h4>首先基于pnpm新建一个空项目</h4>\n<pre><code class=\"language-sh\">  pnpm init\n</code></pre>\n<h4>安装所需模块</h4>\n<pre><code class=\"language-sh\">  # 组件开发相关\n  pnpm add react typescript rxjs\n\n  # 打包相关\n  pnpm add rollup rollup-plugin-typescript2 @rollup/plugin-commonjs @rollup/plugin-node-resolve @rollup/plugin-terser --save-dev\n\n  # 代码lint\n  pnpm add eslint eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-simple-import-sort --save-dev\n  pnpm add husky lint-staged  --save-dev\n\n  # 代码format\n  pnpm add @biomejs/biome --save-dev\n\n</code></pre>\n<h4>lint及format相关配置</h4>\n<ul>\n<li>@biomejs/biome基于rust的开发的format工具(使用默认配置)</li>\n</ul>\n<p>-- tsconfig.json</p>\n<pre><code class=\"language-json\">{\n  &quot;compilerOptions&quot;: {\n    &quot;sourceMap&quot;: true,\n    &quot;module&quot;: &quot;es2015&quot;,\n    &quot;target&quot;: &quot;es2018&quot;,\n    &quot;moduleResolution&quot;: &quot;node&quot;,\n    &quot;outDir&quot;: &quot;./dist&quot;,\n    &quot;jsx&quot;: &quot;react&quot;,\n    &quot;skipLibCheck&quot;: true,\n    &quot;declaration&quot;: true,\n    &quot;declarationMap&quot;: true,\n    &quot;noEmit&quot;: true,\n    &quot;esModuleInterop&quot;: true,\n    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],\n    &quot;strict&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noImplicitReturns&quot;: true,\n    &quot;noFallthroughCasesInSwitch&quot;: true\n  },\n  &quot;include&quot;: [&quot;src&quot;],\n  &quot;exclude&quot;: [\n    &quot;node_modules&quot;,\n  ]\n}\n</code></pre>\n<h5>配置eslintrc</h5>\n<pre><code class=\"language-json\">\t{\n\t&quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,\n\t&quot;plugins&quot;: [&quot;@typescript-eslint&quot;, &quot;react-hooks&quot;, &quot;simple-import-sort&quot;],\n\t&quot;extends&quot;: [\n\t\t&quot;plugin:react/recommended&quot;,\n\t\t&quot;plugin:@typescript-eslint/recommended&quot;\n\t],\n\t&quot;parserOptions&quot;: {\n\t\t&quot;ecmaVersion&quot;: 2020,\n\t\t&quot;sourceType&quot;: &quot;module&quot;,\n\t\t&quot;ecmaFeatures&quot;: {\n\t\t\t&quot;jsx&quot;: true\n\t\t}\n\t},\n\t&quot;rules&quot;: {\n\t\t&quot;curly&quot;: &quot;error&quot;,\n\t\t&quot;no-extra-boolean-cast&quot;: &quot;error&quot;,\n\t\t&quot;cypress/unsafe-to-chain-command&quot;: &quot;off&quot;,\n\t\t&quot;@typescript-eslint/no-non-null-assertion&quot;: &quot;off&quot;,\n\t\t&quot;@typescript-eslint/no-empty-function&quot;: &quot;off&quot;,\n\t\t&quot;@typescript-eslint/ban-ts-comment&quot;: &quot;warn&quot;,\n\t\t&quot;@typescript-eslint/ban-types&quot;: &quot;off&quot;,\n\t\t&quot;@typescript-eslint/no-explicit-any&quot;: &quot;off&quot;,\n\t\t&quot;@typescript-eslint/explicit-module-boundary-types&quot;: &quot;off&quot;,\n\t\t&quot;@typescript-eslint/no-object-literal-type-assertion&quot;: &quot;off&quot;,\n\t\t&quot;@typescript-eslint/no-unused-vars&quot;: [\n\t\t\t&quot;warn&quot;,\n\t\t\t{ &quot;ignoreRestSiblings&quot;: true }\n\t\t],\n\t\t&quot;cypress/no-unnecessary-waiting&quot;: &quot;off&quot;,\n\t\t&quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;,\n\t\t&quot;react-hooks/exhaustive-deps&quot;: &quot;error&quot;,\n\t\t&quot;react/display-name&quot;: &quot;warn&quot;,\n\t\t&quot;react/prop-types&quot;: &quot;off&quot;,\n\t\t&quot;no-console&quot;: [&quot;error&quot;],\n\t\t&quot;simple-import-sort/imports&quot;: [\n\t\t\t&quot;error&quot;,\n\t\t\t{\n\t\t\t\t&quot;groups&quot;: [\n\t\t\t\t\t// Side effect imports.\n\t\t\t\t\t[&quot;^\\\\u0000&quot;],\n\t\t\t\t\t// Packages. `react` related packages come first.\n\t\t\t\t\t[&quot;^react&quot;, &quot;^@?\\\\w&quot;],\n\t\t\t\t\t// Parent imports. Put `..` last.\n\t\t\t\t\t[&quot;^\\\\.\\\\.(?!/?$)&quot;, &quot;^\\\\.\\\\./?$&quot;],\n\t\t\t\t\t// Other relative imports. Put same-folder imports and `.` last.\n\t\t\t\t\t[&quot;^\\\\./(?=.*/)(?!/?$)&quot;, &quot;^\\\\.(?!/?$)&quot;, &quot;^\\\\./?$&quot;]\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\t&quot;simple-import-sort/exports&quot;: &quot;error&quot;\n\t},\n\t&quot;overrides&quot;: [\n\t\t{\n\t\t\t&quot;files&quot;: [&quot;*.test.ts&quot;, &quot;*.test.tsx&quot;],\n\t\t\t&quot;rules&quot;: {\n\t\t\t\t// Allow testing runtime errors to suppress TS errors\n\t\t\t\t&quot;@typescript-eslint/ban-ts-comment&quot;: &quot;off&quot;\n\t\t\t}\n\t\t}\n\t],\n\t&quot;settings&quot;: {\n\t\t&quot;react&quot;: {\n\t\t\t&quot;pragma&quot;: &quot;React&quot;,\n\t\t\t&quot;version&quot;: &quot;detect&quot;\n\t\t}\n\t}\n}\n\n</code></pre>\n<ul>\n<li>husky及lint-staged使用配置 参考官网文档 pre-commit文件配置</li>\n</ul>\n<pre><code class=\"language-sh\">#!/usr/bin/env sh\n. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;\n\npnpm lint-staged\n</code></pre>\n<ul>\n<li>@biomejs/biome + lint-staged 相关配置, package.json文件添加如下代码</li>\n</ul>\n<pre><code class=\"language-json\">\t&quot;scripts&quot;: {\n    ...,\n\t\t&quot;lint&quot;: &quot;eslint '**/*.{js,ts,tsx}'&quot;,\n\t\t&quot;lint:fix&quot;: &quot;pnpm lint --fix&quot;,\n\t\t&quot;prepare&quot;: &quot;husky install&quot;\n\t},\n\n\n\t&quot;lint-staged&quot;: {\n\t\t&quot;*.{js,ts,d.ts,jsx,tsx,json}&quot;: [\n\t\t\t&quot;biome check --files-ignore-unknown=true&quot;,\n\t\t\t&quot;biome check --apply --no-errors-on-unmatched&quot;,\n\t\t\t&quot;biome check --apply --organize-imports-enabled=false --no-errors-on-unmatched&quot;,\n\t\t\t&quot;biome check --apply-unsafe --no-errors-on-unmatched&quot;,\n\t\t\t&quot;biome format --write --no-errors-on-unmatched&quot;,\n\t\t\t&quot;biome lint --apply --no-errors-on-unmatched&quot;,\n\t\t\t&quot;pnpm lint:fix&quot;\n\t\t],\n\t\t&quot;*.{md,yml}&quot;: [&quot;biome format --write --no-errors-on-unmatched&quot;]\n\t},\n\t&quot;husky&quot;: {\n\t\t&quot;hooks&quot;: {\n\t\t\t&quot;pre-commit&quot;: &quot;lint-staged&quot;\n\t\t}\n\t}\n</code></pre>\n<h4>rollup.config.js配置</h4>\n<pre><code class=\"language-js\">import commonjs from &quot;@rollup/plugin-commonjs&quot;;\nimport resolve from &quot;@rollup/plugin-node-resolve&quot;;\nimport terser from &quot;@rollup/plugin-terser&quot;;\nimport typescript from &quot;rollup-plugin-typescript2&quot;;\n\nimport pkg from &quot;../package.json&quot; assert { type: &quot;json&quot; };\n\nexport function createRollupConfig(options, callback) {\n\tconst name = options.name;\n\n\t// A file with the extension &quot;.mjs&quot; will always be treated as ESM, even when pkg.type is &quot;commonjs&quot; (the default)\n\t// https://nodejs.org/docs/latest/api/packages.html#packages_determining_module_system\n\tconst extName = options.format === &quot;esm&quot; ? &quot;mjs&quot; : &quot;js&quot;;\n\n\tconst outputName = `dist/${[name, options.format, extName].join(&quot;.&quot;)}`;\n\n\tconst config = {\n\t\tinput: options.input,\n\t\toutput: {\n\t\t\tfile: outputName,\n\t\t\tformat: options.format,\n\t\t\tname: &quot;AlanUi&quot;,\n\t\t\tsourcemap: true,\n\t\t\t// globals: { react: &quot;React&quot;, rxjs: &quot;rxjs&quot; },\n\t\t\texports: &quot;named&quot;,\n\t\t},\n\t\tplugins: [\n\t\t\tresolve(),\n\t\t\ttypescript({\n\t\t\t\ttsconfig: options.tsconfig,\n\t\t\t\tclean: true,\n\t\t\t\texclude: [&quot;**/__tests__&quot;, &quot;**/*.test.ts&quot;],\n\t\t\t}),\n\t\t\tcommonjs({\n\t\t\t\tinclude: /\\/node_modules\\//,\n\t\t\t}),\n\t\t\toptions.format !== &quot;esm&quot; &amp;&amp;\n\t\t\t\tterser({\n\t\t\t\t\toutput: { comments: false },\n\t\t\t\t\tcompress: {\n\t\t\t\t\t\tdrop_console: true,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t].filter(Boolean),\n\t};\n\n\treturn callback ? callback(config) : config;\n}\n\nconst name = &quot;index&quot;;\nconst options = [\n\t{\n\t\tname,\n\t\tformat: &quot;cjs&quot;,\n\t\tinput: pkg.source,\n\t},\n\t{ name, format: &quot;esm&quot;, input: pkg.source },\n\t{\n\t\tname,\n\t\tformat: &quot;umd&quot;,\n\t\tinput: pkg.source,\n\t},\n];\n\nexport default options.map((option) =&gt; createRollupConfig(option));\n\n</code></pre>\n<h3>测试组件(button)</h3>\n<ul>\n<li>默认出入与导出的问题 这里采用导出由于默认导出不支持 <code>export * from &quot;./button&quot;</code>语法</li>\n</ul>\n<pre><code class=\"language-tsx\">import React, { useEffect, useState } from &quot;react&quot;;\nimport { range, takeLast } from &quot;rxjs&quot;;\n\ninterface Iprops {\n\ttype: &quot;waring&quot; | &quot;danger&quot;;\n}\nexport const AyButton = React.forwardRef(function Button(\n\tprops: Iprops,\n\tref: React.ForwardedRef&lt;HTMLDivElement&gt;,\n) {\n\tconst { type } = props;\n\tconst [state, setState] = useState(0);\n\tuseEffect(() =&gt; {\n\t\tconst many = range(1, 100);\n\t\tconst lastThree = many.pipe(takeLast(3));\n\t\tlastThree.subscribe((x) =&gt; {\n\t\t\tsetState(x);\n\t\t});\n\t}, []);\n\n\treturn (\n\t\t&lt;div ref={ref} className=&quot;button&quot;&gt;\n\t\t\t测试按钮 {type} {state}\n\t\t&lt;/div&gt;\n\t);\n});\n</code></pre>\n<h3>代码地址</h3>\n<p><a href=\"\">地址</a></p>"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>利用Iframe实现局部打印功能</h3>\n<h4>放在需要实现局部的页面内</h4>\n<pre><code class=\"language-html\">  &lt;iframe width=&quot;1&quot; height=&quot;1&quot; id=&quot;printIframe&quot; class=&quot;print-iframe&quot; src=&quot;about:blank&quot;&gt;&lt;/iframe&gt;\n</code></pre>\n<pre><code class=\"language-css\">    .print-iframe {\n      display: none;\n      width: 1px;\n      height: 1px;\n    }\n</code></pre>\n<h3>打印</h3>\n<pre><code class=\"language-ts\">\n  export function previewPdf(nativeElement, name: string) {\n\n    const cloneHtml = nativeElement.cloneNode(true);\n\n    const printIframe = document.getElementById(&quot;printIframe&quot;) as HTMLIFrameElement;\n\n    const newPrintDoc = document.implementation.createHTMLDocument(name);\n\n    try {\n      const link = newPrintDoc.createElement(&quot;link&quot;);\n      link.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;);\n      link.setAttribute(&quot;href&quot;, &quot;../assets/print.css&quot;);\n      newPrintDoc.head.appendChild(link);\n      newPrintDoc.body.appendChild(cloneHtml);\n    } catch(e) {\n      console.log(e);\n    }\n\n    const iframeDocument= printIframe.contentDocument;\n    const newPrintDocumentElement = newPrintDoc.documentElement;\n    const newNode = iframeDocument.importNode(newPrintDocumentElement, true);\n    iframeDocument.replaceChild(newNode, iframeDocument.documentElement);\n\n    setTimeout(()=&gt;{\n      printIframe.contentWindow.print();\n    },1000)\n\n  }\n\n\n</code></pre>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>angular</h3>\n<h3>react</h3>\n<h3>vue</h3>\n<h3>solid</h3>\n<h3>svelte</h3>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>mqtt浏览器端 使用</h3>\n<pre><code class=\"language-javascript\">\n      try {\n\n        const api = &quot;ws://test.com:8083&quot;\n        const options = {\n          clean: true, \n          connectTimeout: 4000,\n          clientId: '',\n          username: '',\n          password: '',\n        }\n\n        const client = mqtt.connect(api, options)\n        client.on('connect', function () {\n\n          console.log(&quot;hello&quot;, &quot;连接成功&quot;)\n\n          client.on('message', (topic, message) =&gt; {\n            console.log('收到消息：', topic, message.toString())\n          }\n\n          client.publish(&quot;hello&quot;, &quot;this is test&quot;, { qos: 1, rein: false } , () =&gt; {\n            console.log(eventTopic, &quot;发送成功&quot;)\n            client.end()\n          });\n\n        })\n      } catch {\n\n        console.error(&quot;出错了&quot;)\n\n      }\n\n</code></pre>\n<p>具体信息参考文档 <a href=\"https://github.com/mqttjs/MQTT.js#client\">地址</a></p>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<pre><code>项目上线后的一次总结\n</code></pre>\n<p>最近项目刚刚上线，清闲了一点来聊一聊用到的工具。ps: 有一样的的可以加个好友一块探讨技术。</p>\n<p>项目的前端部分完全采用hooks的方式。相较与class的生命周期，是省去了很多的代码，在加上antd4对hook进行了支持，特别是对form进行了大量的重构。\n对表单的处理越来越方便，简洁，直观。</p>\n<p>下面说下rxjs在项目中用的比较多的地方</p>\n<ol>\n<li>\n<p>ajax使用rxjs进行简单的封装<a href=\"https://www.jackeybiao.com/#/post/10\">这里有介绍</a>，</p>\n</li>\n<li>\n<p>使用rxjs进行局部、全局的状态管理<a href=\"https://www.jackeybiao.com/#/post/7\">这里有介绍</a></p>\n</li>\n<li>\n<p>函数防抖<a href=\"https://www.jackeybiao.com/#/post/8\">这里有介绍</a></p>\n</li>\n</ol>\n<p>下面是用到的一些开源工具</p>\n<ol>\n<li>\n<p>antd组件</p>\n</li>\n<li>\n<p>引入typescript</p>\n</li>\n<li>\n<p>keycloak实现的用户管理，菜单，路由，权限管理</p>\n</li>\n<li>\n<p>echarts做的可视化页面</p>\n</li>\n<li>\n<p>husky + prettier + pretty-quick 做的代码格式化(未对代码格式问题进行提交报错处理)</p>\n</li>\n<li>\n<p>scss等工具</p>\n</li>\n</ol>\n<h3>开发中遇到的问题</h3>\n<ol>\n<li>keycloak接入路由与权限和菜单匹配问题</li>\n</ol>\n<p>处理方式：前端固定路由，用获取过来的用户菜单进行路由和菜单匹配过滤无权限的路由，然后进行路由渲染。</p>\n<ol start=\"2\">\n<li>项目中查询结合table的页面很多导致很多代码重复。</li>\n</ol>\n<p>处理方式：整理了一个form和和table公用的hooks。减少不必要的代码<a href=\"https://www.jackeybiao.com/#/post/16\">这里有做介绍</a>。</p>\n<ol start=\"3\">\n<li>项目上线</li>\n</ol>\n<p>再上线过程中，使用jenkins部署过程中发现npm里面下不到node-sass包，导致部署老是失败。最后被迫使用了阿里的npm镜像。部署上线。</p>\n<ol start=\"4\">\n<li>typescript升级问题</li>\n</ol>\n<p>再项目开发过程中，typescript从3.7直接跳到了3.9，3.9带来了很多性能上的提升，就想着升级版本。升级以后发现部署报错。。着急。发现很多webpack里面的配置需要进行修改和部分react的工具要进行升级。(项目用的create-react-app reject)。最后项目赶工，就没来得及直接回退了版本。后面闲了再进行升级。</p>\n<ol start=\"5\">\n<li>最后吐槽一下</li>\n</ol>\n<p>编码规范，和文档是多么的重要！！！</p>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h4>对vue3的一点吐槽</h4>\n<p>前些年，用过进1年vue2+, 后面react16.8出来以后，就没有在进一步接触vue，也就偶尔用vue写写小程序。</p>\n<p>近期因为“项目”需要着手基于vue3开发一款基于electron的window桌面端应用。在之前也看过一些vue3的反应式api，没用之前感觉和hook差不多。语法方面也有很多相近，调研阶段甚至看到了用jsx写vue3。但是在实际开发中，遇到了很多自我感觉不是很简洁的语法。写过很久的react的实在无法忍受。</p>\n<p>vue2阶段，一个props属性，在组件里我们可以像下面这么调用</p>\n<pre><code class=\"language-ts\">...,\nprops: [&quot;title&quot;, &quot;name&quot;]\n\nmethod: {\n  handleClick() {\n    console.log(this.title)\n  }\n}\n\n...,\n\n</code></pre>\n<p>这样我们就可以在方法里面基于vm.属性就可以访问。当到了vue3，我们需要下面这样</p>\n<pre><code class=\"language-ts\">...,\nprops: [&quot;title&quot;, &quot;name&quot;]\nsetup(props) {\n\n  const { title, name } = toRefs(props)\n\n\n  const handleClick = () =&gt; {\n\n    console.log(title.value)\n  }\n}\n...,\n\n</code></pre>\n<p>vue3中想要响应式,全要加一堆的特定语法,包括定义一个state需要用到<code>ref</code> or <code>reactive</code>等方法，当然react中有<code>useState()</code>。react中也有props。下面稍微做一个对比。</p>\n<pre><code class=\"language-ts\">\n...\n\nconst { title, name } = props;\n\nconst handleClick = () =&gt; {\n  console.log(title);\n}\n\n...\n\n</code></pre>\n<p>干脆升级，我还要写更多的代码量。 ---- 不能忍之一</p>\n<p>下面看state。基于react的useState():</p>\n<pre><code class=\"language-ts\">...\n\n  const [title, setTitle] = useState&lt;string&gt;(&quot;&quot;);\n\n  const handleClick = () =&gt; {\n    setTitle(&quot;你最珍贵~&quot;);\n  }\n\n...\n\n\n</code></pre>\n<p>再来看基于vue3；</p>\n<pre><code class=\"language-ts\">...\n\n  const title = ref(&quot;&quot;)\n\n  const handleClick =&gt; () =&gt; {\n    title.value = &quot;你最珍贵~&quot;;\n  }\n\n  // 重要不能少！\n  return {\n    title,\n  }\n\n...\n\n</code></pre>\n<p>这里关于定义状态的虽说代码量差不多，刚开始写vue3的我来说，复杂的业务逻辑，我做个判断我居然不能直接用变量。必须要用.value格式。我真的吐了。比如像下面这样：</p>\n<pre><code class=\"language-ts\">...\n\n  const online = ref(true);\n\n\n  const handleClick = () =&gt; {\n    if(online) {\n      ... // 做了某些造作\n      online = false\n    }\n  }\n\n...\n\n</code></pre>\n<p>这个判断用过的都知道使用的有问题。但是真的一个业务组件，不知道要用state做多少判断。每一个state没做一次判断我居然要多些5个字母。我知道<code>ref</code>,<code>toRefs</code>是为了响应式。但是我是真的会忘记写.value。这个语法。。。。。我只能给零分。包括一还有一堆为了满足响应式而出现的新api。最后我调用vuex，想要响应式也要用到.value。 我....</p>\n<p>下面是函数回调：</p>\n<p>vue2中：</p>\n<pre><code class=\"language-ts\">...\n\n  method: {\n    handleClick() {\n      this.$emit(&quot;setName&quot;, &quot;你最珍贵~&quot;)；\n    }\n}\n\n...\n\n</code></pre>\n<p>我还能勉强接受。下面是vue3中：</p>\n<pre><code class=\"language-ts\">...\n  emit:[&quot;setName&quot;],\n\n  setup(props, content){\n\n    const handleClick = () =&gt; {\n      content.emit(&quot;setName&quot;, &quot;你最珍贵~&quot;)\n    }\n\n  }\n\n...\n\n</code></pre>\n<p>别告诉我，新api你不用, 但是我真的用不起，抱歉，还是选react和angular。还有个不想吐槽，但是还是拿出来说下</p>\n<p>我写个组件，组件中简单用个slot替代父级传过来的dom,多个我可以加name，我说这么感觉写的很顺手的，结果我用组件的时候, 我的天,一堆template是什么鬼, 我写组件是为了简化代码的,结果我还是要写一堆的'样式代码'纯粹的'样式代码'。</p>\n<p>真的用不起vue3,拜拜您来。。。</p>\n"
    },
    {
      "title": "",
      "category": "",
      "tags": "",
      "outstanding": false,
      "content": ""
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>企业微信客户端网页应用开发（JS-SDK）</h3>\n<ol>\n<li>项目直接用react搭建。</li>\n</ol>\n<h4>应用具体实现功能</h4>\n<ol>\n<li>服务商后台-员工标签管理等</li>\n<li>企业微信登录-服务商后台</li>\n<li>企业微信客户端网页应用-服务于不同的企业。进行相关的功能管理。</li>\n<li>网页应用页面的<code>快捷聊天工具栏</code></li>\n</ol>\n<h4>遇到问题</h4>\n<p>主要在功能<code>3、4</code>。网页应用调用JS-SDK, 页面都需要调用<code>wx.config</code>和<code>wx.agentConfig</code>才能继续调用企业微信相关的客户端api。</p>\n<ol>\n<li>\n<p>开发页面过程中发现，页面与服务端的流程始终串不通。缺少<code>corpid</code>、<code>agentid</code>、<code>Secret</code>等。后台没有渠道获取，页面这边只能获取到登录后人员的<code>corpid</code>。</p>\n</li>\n<li>\n<p>获取方式\n想要调用JS-SDK就需要具体使用应用的企业自建一个企业应用，建好以后可以获取到对应的<code>agentid</code>、<code>Secret</code>。（每个企业只要使用都需要建一个...）。</p>\n</li>\n</ol>\n<h4>我的处理方式</h4>\n<p>具体流程：</p>\n<ol>\n<li>\n<p>企业在企业微信安装我们的应用。安装应用后，</p>\n</li>\n<li>\n<p>如果想添加<code>快捷聊天工具栏</code>，需要我们去为该企业手动创建一个自建应用。</p>\n</li>\n<li>\n<p>然后获取相应的<code>agentid</code>、<code>Secret</code>，然后手动与该企业的<code>corpid</code>绑定。（悄悄关联保存的我们数据库）</p>\n</li>\n<li>\n<p>后台根据<code>corpid</code>去查询<code>agentid</code>、<code>Secret</code>，然后进行相关功能开发。</p>\n</li>\n<li>\n<p>在不添加<code>快捷聊天工具栏</code>的情况下，企业微信客户端相关页面不能使用需要首先调用<code>agentConfig</code>的企业微信客户端api。</p>\n</li>\n</ol>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>shell常用命令备忘</h3>\n<h4>ls 列出文件</h4>\n<pre><code>`ls -la` 列出当前目录下的所有文件和文件夹\n`ls a*` 列出当前目录下的所有以a字母开头的文件\n`ls -l *.txt` 列出当前目录下所以后缀名为txt的文件\n</code></pre>\n<h4>cp 复制</h4>\n<pre><code>`cp a.txt b.txt` 把文件a的内容复制到b文件\n`cp a.txt ./test` 把文件a复制到test目录下\n`cp -a test test2` 递归的把目录test下的所有文件（包括隐藏的文件）复制到新的目录 test2\n</code></pre>\n<h4>cat 查看 和 组合文件</h4>\n<pre><code>`cat a.txt` 查看文件内容\n`cat a.txt &gt;&gt; b.txt` 把a文件的内容组合到b文件内容的末尾\n`cat -n a.txt` 查看文件并给文件按标上行号\n</code></pre>\n<h4>touch 创建文件</h4>\n<pre><code>`touch a.txt` 创建一个名为a的txt类型文件\n</code></pre>\n<h4>rm 删除文件</h4>\n<pre><code>`rm -rf a.txt` 强制删除文件a.txt\n`tm -i a.txt` 删除文件前会有提示 是否确定删除该文件\n</code></pre>\n<h4>mkdir 创建目录</h4>\n<pre><code>`mkdir test` 在当前目录下创建名为test的目录\n</code></pre>\n<h3>rmdir 删除目录</h3>\n<pre><code>`rmdir test` 删除当前目录下的test目录\n</code></pre>\n<h4>mv 移动 重命名文件</h4>\n<pre><code>`mv a.txt b.txt` 将文件a.txt重命名为b.txt\n`mv a.txt ./test` 将文件a.txt移动到test目录下\n</code></pre>\n<h4>cd 更换目录</h4>\n<pre><code>`cd ~` 切换到用户目录\n`cd ..` 返回到上一层目录\n`cd ./test/` 进入test目录\n</code></pre>\n<h4>grep 搜索文件</h4>\n<pre><code>`ls -la | grep a.txt` 搜索a.txt文件\n</code></pre>\n<h4>find 查找文件 和搜索目录</h4>\n<pre><code>`find filename` 查找当前文件夹下是否有该文件或目录\n</code></pre>\n<h4>rz sz 上传和下载文件</h4>\n<h4>head 显示文件前10行内容</h4>\n<pre><code>`head a2.txt` 显示a2.txt的前10行内容\n</code></pre>\n<h4>tail 显示文件最后10行内容</h4>\n<pre><code>`tail a2.txt` 显示a2.txt的最后10行内容\n</code></pre>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<pre><code>最近做一个node层处理转发api的服务，其他方法都没啥问题，走到post方法接收formData数据的时候，除了问题。尝试了几种方法都没有走通，最后由于其他事情就搁置了几天，这两天闲一点就专门研究了下。\n</code></pre>\n<p>由于第一次接触转发的概念，formData数据起初的理解是从前端获取到formdata数据然后在中间层处理封装成formdata然后，传给后端就可以了。\n最后理解思路是对的但是一直没有搞好传值给后端的实现方法。</p>\n<p>最后完成的代码如下：</p>\n<pre><code class=\"language-js\">\n    const uploadRouter = require('koa-router')();\n\n    var FormData = require('form-data');\n    var axios = require('axios');\n    const fs = require('fs')\n    const path = require('path')\n\n\n    uploadRouter.post('/upload', async (ctx, next) =&gt; {\n\n      const file = ctx.request.files.file\n\n      const reader = fs.createReadStream(file.path);\n      let filePath = path.join(__dirname, './public/upload/') + `/${file.name}`;\n      // 创建可写流\n      const upStream = fs.createWriteStream(filePath);\n      // 可读流通过管道写入可写流\n      reader.pipe(upStream);\n\n      var form = new FormData();\n      form.append('file', reader);\n\n      let getHeaders = (form=&gt;{\n        return new Promise((resolve,reject)=&gt;{\n          form.getLength((err,length)=&gt;{\n            if(err) reject(err)\n            let headers = Object.assign({'Content-Length':length},form.getHeaders())\n            resolve(headers)\n          })\n        })\n      })\n\n\n      getHeaders(form)\n        .then(headers=&gt;{\n          return axios.post(url,form,{headers:headers})\n        })\n        .then((response)=&gt;{\n          console.log(response.data);\n        })\n        .catch(e=&gt;{console.log(e)})\n\n        return ctx.body = &quot;上传成功！&quot;;\n\n    });\n\n    module.exports = uploadRouter.routes();\n\n\n\n\n</code></pre>"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>前端工程化</h3>\n<pre><code>我的简单理解，从随着前端后端分离的普及, nodejs在前端开发的过程中变得尤为重要，伴随着的是前端复杂度的提高，越来越多的软件工程知识被带入到前端开发中来。\n随着前端发展的越来越成熟，工程的思想在前端慢慢的普及，前端变得规范化、标准化。\n</code></pre>\n<h4>工程化给前端带来的好处</h4>\n<p>为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间</p>\n<h4>主要包含的内容</h4>\n<p>开发层面: 软件开发的组件化、模块化、规范、标准化等（目前做的最好的angular、react、vue）。\n运维测试层面: 单元测试、e2e测试、自动化构建，自动化发布等（单元测试框架Mocha, <code>Jasmine</code>, Jest, Cucumber等，及自动化构建工具jenkins等）。\n协作方面：代码管理工具的使用、代码仓管理工具等（git\\svn\\gerrit等）。</p>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<p>在前端越来越规范话的前提下，面对各种人物，写出的层次不齐的代码，看到自己的封装的代码被破坏，真的头大。</p>\n<p>下面说下我在react hook项目开发中的一些自我约定：</p>\n<ol>\n<li>\n<p>组件封装问题： 组件封装我有时候会按照从小到大的原则进行文件夹提取，比如在home文件夹下，存在一个home文件夹范围内可用的组件。而如果这个范围内的组件被其他文件夹(页面)也用到，就可以把组件提取到公用的compoents文件夹下，而不是拷贝一份放到用到其组件的文件夹下。</p>\n</li>\n<li>\n<p>公用hooks问题：公用的useHooks，在运行良好的情况下，尽可能不要去改动。特别是维护项目的时候。公用useHooks里处理外来参数是什么鬼（可以分情况对待）。处理form表单参数，我真的不能理解。</p>\n</li>\n<li>\n<p>useState使用问题。尽可能少的使用useState。一个页面只是为了展示，而定义很多个字段，是什么鬼。后端传过来的Object对象，尽可能的不要拆分（拆就拆也要分情况拆啊）多写了几十行没用代码，自己不清楚吗。</p>\n</li>\n<li>\n<p>状态问题，在为引入redux的前提下尽可能使用useContext和useReduce。</p>\n</li>\n<li>\n<p>多个状态需要处理时尽可能使用useReduce。</p>\n</li>\n<li>\n<p>公用hooks如果有返回值，尽可能使用useMemo进行返回</p>\n</li>\n<li>\n<p>具体的（组件）公用组件中，尽可能少的处理数据。</p>\n<p>最后：多看几遍官网的hook规则和Hooks FQA。 后面再更。</p>\n</li>\n</ol>\n"
    },
    {
      "title": "Vim",
      "category": "doc",
      "tags": "",
      "outstanding": false,
      "content": "<h3>前端实现动态表单</h3>\n<pre><code>缘起：项目中很多页面是可查询表格页面；后端由于历史原因又无法给每个页面添加自定义的查询表单元数据的接口；于是有了下面的前端的处理方式\n</code></pre>\n<p>项目代码基于 antd-design 的 form 组件,当然其他的也可以自行修改使用,通过 hooks 获取后端对应的字典数据并处理，eg：处理表单查询联动等问题</p>\n<p>首先，定义定义 form 表单的元数据(可自行按需扩展)</p>\n<pre><code class=\"language-ts\">// 元数据类型定义\ninterface IFormItem {\n  name: string;\n  label: string;\n  type: &quot;input&quot; | &quot;select&quot; | &quot;multiple&quot; | &quot;checked&quot; | &quot;radio&quot;;\n  onChange?: (e: any) =&gt; void;\n  options?: { value: number | string; label: string }[];\n}\n</code></pre>\n<p>然后根据相应的类型定义 searchForm 组件;</p>\n<h3>表单元数据拼接</h3>\n<p>每个 hooks 对应一个或多个(需要联动的话)后端的字典数据，然后结合页面需求对个个 hooks 进行拼接组合，生成 form 元数据，传入 searchForm 组件即可。</p>\n<pre><code class=\"language-tsx\">// 通过hooks获取远程数据也可自定义数据eg:\nconst useSeachYearAndMonth = (form) =&gt; {\n\n  const years = [{value:2023,label: &quot;2023年&quot;}, {value:2022, label: &quot;2022年&quot;}]；\n  const [month, setMonth] = useState&lt;{name:number, label: string}[]&gt;([])\n\n  const handleChangeYear = (e:any) =&gt; {\n    const months = [1,2,3,4,5,6,7,8,9,10,11,12];\n    const lastMonth = Math.floor(Math.random() * 10);\n    setMonth(months.slice(0,lastMonth).map(item=&gt;({\n      value: item,\n      label: `${item}月`\n    })));\n    form.setFieldValue({\n      ...form.getFieldsVlaue(),\n      month:null\n    })\n  }\n\n\n  const config:IFormItem[] = [\n    {\n      name:&quot;year&quot;,\n      label:&quot;年份&quot;,\n      type:&quot;select&quot;,\n      onChange: handleChangeYear,\n      options: years\n    }, {\n      name: &quot;month&quot;,\n      label: &quot;月份&quot;,\n      type:&quot;select&quot;,\n      options: month,\n    }\n  ]\n\n  return config;\n}\n\n\nconst useSearchName = (form, option?: {name?: string, label?:string, type: string}) =&gt; {\n  return [{\n    name: option?.name || &quot;name&quot;,\n    label: option?.label || &quot;姓名&quot;,\n    type: option?.type || &quot;input&quot;,\n  }]\n}\n\n\n</code></pre>\n<h4>使用</h4>\n<p>在相关页面的第一个层级使用一下方式，组合个个查询条件。</p>\n<pre><code class=\"language-tsx\">// 拼接元数据传给form组件即可\nconst formDataSource: IFormItem[] = [\n  {\n    name: &quot;name&quot;,\n    label: &quot;姓名&quot;,\n    type: &quot;input&quot;,\n  },\n  ...useSearchName(form),\n  ...useSeachYearAndMondth(form),\n];\n</code></pre>\n"
    }
  ]
}